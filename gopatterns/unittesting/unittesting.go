// Package unittesting attempts to show patterns I follow when unittesting.
//
// The video below is a great talk and where I derive much of these patterns.
//
//	Title: Advanced Testing in Go by Mitchell Hashimoto
//	Link:  http://www.youtube.com/watch?v=yszygk1cpEc&t
//
package unittesting

import (
	"flag"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
)

/******************************************************************************
 * Simple Function Unittest
 *****************************************************************************/
// I define a simple function as function that can be treated as a black box.
//
//				/--------\
//	INPUTS --> | Function | --> OUTPUTS
//				\--------/

// Add is a simple function that will be tested.
func Add(a, b int) int {
	return a + b
}

// TestAdd is a test function that tests Add(). To use go test, it is necessary to
// prefix the function with Test..., and convention to name it TestFunctionUnderTest
func TestAdd(t *testing.T) {

	// Create an anonymous struct
	testcases := map[string]struct {

		// Create fields for inputs to the function
		inputA int
		inputB int

		// Create field for expected results
		expected int
	}{
		// Add test cases here
		"simple add": {
			inputA:   1,
			inputB:   1,
			expected: 2,
		},
		"add positive to zero": {
			inputA:   5,
			inputB:   0,
			expected: 5,
		},
		// ... this unit test below will fail
		"what am i doing wrong?? ðŸ˜­ ": {
			inputA:   1,
			inputB:   1,
			expected: 999999,
		},
	}

	// Iterate through test cases
	for msg, tc := range testcases {

		// Capture actual value
		actual := Add(tc.inputA, tc.inputB)

		// Use assert package to check values
		//
		// DESPITE GO COMMUNITY's BELIEFS that the standard testing package is
		// enough. Using github.com/stretchr/testify helps immensely in
		// cleaning up test code.
		//
		// And the best part is that testify is just library, not a framework.
		// You can choose to use testify in some of your unittests or not use
		// it in others. You can mix and match, and it plays very well with
		// go test.
		assert.Equal(t, tc.expected, actual, msg)

		// Use require package if you want to stop test upon a test case failure
		// require.Equal(t, tc.expected, actual, msg)
	}
}

/******************************************************************************
 * Using the mock package
 *****************************************************************************/

// The easiest way to create mocks is to use mockery. Mockery generates mock
// objects for a specified interface using the stretchr/testify/mock framework.
//
// It is common to call run mockery via go generate, so you don't need to remember
// how to specify which mocks to use and where to output them.
//
// WARNING: Example below will not work because this is a test file =P. But I swear
// it will work if you use it in any non *_test.go source code.
//
// go:generate mockery -name=Adder
type Adder interface {
	Compute(a int, b int) int
}

// NOTE: This was copied from code generate by mockery. You CANT run go generate
// on test code. But you CAN run mocker directly. If you want to try generateing
// the below structure, you can run:
//
//     mockery -name=Adder example_test.go

// MockAdder is an autogenerated mock type for the MockAdder type
type MockAdder struct {
	mock.Mock
}

// Compute provides a mock function with given fields: a, b
func (_m *MockAdder) Compute(a int, b int) int {
	ret := _m.Called(a, b)

	var r0 int
	if rf, ok := ret.Get(0).(func(int, int) int); ok {
		r0 = rf(a, b)
	} else {
		r0 = ret.Get(0).(int)
	}

	return r0
}

// Past an interface into the function. Remember, INTERFACE = MOCKING POINTS
// As such you should always be using an interface for external services
func UseAdder(add Adder, a, b int) int {
	return add.Compute(a, b)
}

func TestUseAdder(t *testing.T) {

	// Create an instance of the mock object
	m := &MockAdder{}

	//  Set function name and arguements
	//  .On( "Compute", 1, 1 )
	//
	//  Set return value
	//  .Return()
	//
	//  You can specify how many time to return this value when given this input
	//  If Once(). is not specified, it defaults to always
	//  .Once()
	//

	m.On("Compute", 1, 1).Return(2).Once()
	assert.Equal(t, 2, UseAdder(m, 1, 1), "simple mock")

	// I CAN DO ANYTHING
	//
	// Now since once was not called here, we will forever now return 12345
	// anytime we are given the inputs 1, 1
	m.On("Compute", 1, 1).Return(12345)
	assert.Equal(t, 12345, UseAdder(m, 1, 1), "jeff is a testing genius")

	// If we don't care about what inputs are given, which is often the case.
	// You can use mock.AnythingOfType(...).
	//
	// NOTE: You can only specify concrete types, even if the function takes an interface
	//
	m.On("Compute", mock.AnythingOfType("int"), mock.AnythingOfType("int")).Return(10)
	assert.Equal(t, 10, UseAdder(m, 1234, 6789), "anything is possible")
}

/******************************************************************************
 * Testing Helper Functions
 *****************************************************************************/
//
// VIDEO: http://www.youtube.com/watch?v=yszygk1cpEc&t=20m2s
//
// RULE #1: CREATE HELPER FUCTIONS WHEN NEEDED
//
// THIS
// IS
// SO
// IMPORTANT
//
// that it needed its own section...
//
// Unit test code is like any other code. If functionality complex and/or is
// used in alot of tests, it is generally a good idea to create a helper
// fuction to breakout that logic.
//
func EqualSets(seta []int, setb []int) bool {
	if len(seta) != len(setb) {
		return false
	}
	for _, a := range seta {
		var found bool
		for _, b := range setb {
			if a == b {
				found = true
			}
		}
		if !found {
			return false
		}
	}
	return true
}

func TestSomethingWithSets(t *testing.T) {
	testcases := []struct {
		message string
		setA    []int
		setB    []int
	}{
		{
			message: "exact set",
			setA:    []int{1, 2, 3},
			setB:    []int{1, 2, 3},
		},
		{
			message: "scrambled",
			setA:    []int{1, 2, 3},
			setB:    []int{3, 1, 2},
		},
	}
	for _, tc := range testcases {
		assert.True(t, EqualSets(tc.setA, tc.setB), tc.message)
	}
}

/******************************************************************************
 * Golden Files
 *****************************************************************************/
// Golden files are usefule for verify complex outputs.
//
// The output of a function is recorded as a goldenfile and verified manually
// the very first time. Then regression tests are run with this golden file
// as the expectation.
//
// If implementation details change, and may affect the output of the function.
// Then you can capture a new golden file, and use your source control tool
// to inspect the diff to see if the changes are what you expected.
//
var flagUpdate bool

func init() {
	flag.BoolVar(&flagUpdate, "-update", false, "Update goldenfiles")
	flag.Parse()
}

func WriteToFile(path string, s interface{}) {
	// Write to file in a specific format (i.e. CSV, JSON, raw binary)
}

func ReadFromFile(path string, s interface{}) {
	// Read from in the same format (i.e. CSV, JSON, raw binary)
}

func TestAddAgain(t *testing.T) {
	testcases := map[string]struct {
		inputA int
		inputB int

		// Define place to put golden file
		goldenpath string
	}{
		"normal": {
			goldenpath: "path/to/unittest-file.golden",
			inputA:     1,
			inputB:     2,
		},
	}
	for msg, tc := range testcases {

		actual := Add(tc.inputA, tc.inputB)

		// Notice if flagUpdate is true, we will update the golden file
		// and this testcase should always pass.
		if flagUpdate {
			WriteToFile(tc.goldenpath, actual)
		}

		// Parse golden file into expected structure.
		var expected int
		ReadFromFile(tc.goldenpath, &expected)

		// Use the same expected vs actual patter we used before.
		assert.Equal(t, expected, actual, msg)
	}

}
